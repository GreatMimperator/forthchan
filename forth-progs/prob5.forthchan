:prob_five
    gen_pow_array_with_start_link
    2 pick 1 + 2    \ head -> (2, to + 1 (exc), array_start_link, [array])
    doi             \ head -> (делитель, array_start_link, [array])
        3 pick      \ head -> (to, делитель, array_start_link, [array])
        gen_pow_array_with_start_link   \ head -> (subarray_start_link, [subarray], делитель, array_start_link, [array])
        dup 1 + 1 + roll                \ head -> (делитель, subarray_start_link, [subarray], array_start_link, [array])
        1 pick 1 + 1 roll dup           \ head -> (делитель, делитель, subarray_start_link, subarray_start_link, [subarray], array_start_link, [array])
        init_pow_array            \ head -> (subarray_start_link, [subarray], array_start_link, [array])
        dup 1 + 1 + pick 1 pick 2 + 1 + +    \ head -> (array_start_link, subarray_start_link, [subarray], array_start_link, [array])
            \ взять subarray_start_link, добавить сдвиг до вершины, добавить сдвиг на array_start_link, взять, добавить сдвиг на начало [subarray], взять subarray_start_link, добавить сдвиг до вершины, суммировать сдвиги
        1 pick 2 + 1 + 2 + pick                 \ head -> (to, array_start_link, subarray_start_link, [subarray], array_start_link, [array])
        dup 3 roll 1 + 3 roll 1 + 3 roll        \ head -> (to, array_start_link, subarray_start_link, to, [subarray], array_start_link, [array])
        merge_pow_arrays                        \ head -> (to, [subarray], array_start_link, [array])
        clean_pow_array                         \ head -> (array_start_link, [array])
    loop
    dup 1 + 3 pick
    calc_pow_array_mul
    swap put
    1 pick 1 -
    clean_pow_array
    drop
;

:clean_pow_array    \ head -> (to, [array])
    2 - 1 + 2 *
    0
    do
        drop
    loop
;

:init_pow_array \ head -> (pow_array_max, number, array_start_link, [...], [array]) {consumes num, pow_array_max and asl}
    1 +     \ pow_array_max + 1 (exc)
    2
    doi     \ head -> (2..to + 1 (exc), number, asl)
        0 rot rot       \ head -> (base, number, power=0, asl)
        dudup mod if            \ head -> (number mod base, base, number, power, asl)
            begin               \ head -> (base, number, power, asl)
                swap 1 pick / swap      \ head -> (base, number / base, power, asl)
                rot 1 + rot rot         \ head -> (base, number / base, power + 1, asl)
            dudup mod until
        then
        \ head -> (base, number, power, asl)
        2 - 2 *         \ head -> (2*(base-2), number, power, asl)
        3 pick 4 +      \ head -> (asl, 2*(base-2), number, power, asl)
        swap - 1 - 2 -      \ head -> (base_pow_pos, number, power, asl)
        rot swap        \ head -> (base_pow_pos, power, number, asl)
        put             \ head -> (number, asl)
    loop
    drop drop           \ head -> ([...], [array])
;

:pow    \ head -> (power, number)
    1       \ head -> (mul, power, number)
    1 pick 0 <> if
        begin
            2 pick *        \ head -> (mul * number, power, number)
            swap 1 - swap   \ head -> (mul * number, power - 1, number)
        1 pick 0 <> until
    then
    \ head -> (mul, power=0, number)
    1 put
    drop
;

:merge_pow_arrays \ head -> (to, array_start_link, subarray_start_link)
    1 +
    2
    doi     \ head -> (2..to + 1 (exc), asl, s_asl)
        2 - 2 * 1 +     \ (shift to pow of index, asl, s_asl)
        dup             \ (sh, sh, asl, s_asl)
        3 pick 4 +      \ (s_asl, sh, sh, asl, s_asl)
        swap - 1 -      \ (s_asl - sh (sasl pow), sh, asl, s_asl)
        pick            \ (sasl pow got, sh, asl, s_asl)
        2 pick 3 +      \ (asl, sasl pow, sh, asl, s_asl)
        2 pick -        \ (asl - sh (asl pow), sasl pow, sh, asl, s_asl)
        pick            \ (asl pow got, sasl pow got, sh, asl, s_asl)
        dudup >         \ (sasl pow > asl pow, asl pow, sasl pow, sh, asl, s_asl)
        if
            drop            \ (sasl pow, sh, asl, s_asl)
            2 pick 3 +      \ (asl, sasl pow, sh, asl, s_asl)
            rot - 1 - 1 -   \ (asl - sh FOR PUT, sasl pow, asl, s_asl)
            put             \ (asl, s_asl)
        else
            drop drop drop  \ (asl, s_asl)
        then
    loop
    drop drop   \ () means drops asl and s_asl
;

:calc_pow_array_mul \ head -> (to, array_start_link)
    1 rot 1 + rot       \ (to, array_start_link, mul)
    1 +         \ to + 1
    2
    doi   \ head -> (2..to + 1 (exc), array_start_link, mul)
        2 - 2 *
        1 pick 2 +          \ head -> (array_start_link, 2 * (i - 2), array_start_link, mul)
        swap -               \ head -> (asl - 2*(i-2), array_start_link, mul)
        dup 1 -             \ head -> (asl - 2*(i-2) - 1, asl - 2*(i-2), asl, mul)
        pick swap pick           \ head -> (num, power, asl, mul)
        3 roll                  \ head -> (mul, num, power, asl)
        1 roll                  \ head -> (num, mul, power, asl)
        2 pick 0 <> if  \ check power = 0
            begin
                dup 2 roll * swap       \ head -> (num, mul * num, power, asl)
                rot 1 - rot rot 2 pick  \ head -> (power - 1, num, mul * num, power - 1)
            0 <> until
        then
        drop                    \ head -> (mul, power, asl)
        swap drop               \ head -> (mul, asl)
        swap                    \ head -> (asl, mul)
    loop
    drop            \ head -> (mul)
;

:gen_pow_array_with_start_link
    gen_pow_array
    1 pick
    1 - 2 * 1 -
;

:gen_pow_array \ head -> (to) {consumes}
    1 + \ include to
    2
    doi
        0
    loop
;

20
prob_five